GET

•	/api/currencies?date=<date>

  SELECT CurrencyCode, ValueInUSD
  FROM CurrencyValuations
  WHERE datetime(DateOfValuation) = datetime(<string date>);

  datetime expects a string of YYYY-MM-DD, dummy data is in form DD-MM-YYYY
  as long as we don't touch the time part it will default to 00:00:00
  can look into string reversal functions to allow DateOfValuation to be stored in DD-MM-YYYY

•	/api/companies?date=<date>

  SELECT CompanyCode, CompanyName
  FROM Companies
  WHERE datetime(DateEnteredInSystem) <= datetime(<string date>);

•	/api/products?date=<date>

  SELECT ProductName, MarketPrice
  FROM ProductValuations NATURAL JOIN Products
  WHERE datetime(DateOfValuation) = datetime(<string date>);

•	/api/trades?filter=<filter object>

  very dependent on what the filter is
  need to refine these as currently select * is a lot of fields

  - isDryRun (return the number of matches and not the matches themselves)

    replace the first line of any query below with

      SELECT COUNT(*)

  - date range (startData, endDate) (date when created or last modified?)

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE datetime(DateOfTrade) BETWEEN datetime(<string date>) AND datetime(<string date>)
    ORDER BY datetime(DateOfTrade) DESC;

    datetime() might not be needed in orderby, don't know how sqlite deals with string ordering

  - exact tradeID

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE TradeID = ?
    ORDER BY DateOfTrade DESC;

  - companies involved

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE BuyingParty = ? OR SellingParty = ?
    ORDER BY DateOfTrade DESC;

    could be split into 2 more, just filtering on BuyingParty/SellingParty not both as well as this one

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE BuyingParty = ?
    ORDER BY DateOfTrade DESC;

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE SellingParty = ?
    ORDER BY DateOfTrade DESC;

  - product name

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE ProductName = ?
    ORDER BY DateOfTrade DESC;

  - currency

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE UnderlyingCurrency = ?
    ORDER BY DateOfTrade DESC;

  - commodity value (which exact value are we filtering by though)

    unsure what this means

  - userID created by

    we only have last edited in database right now UNFINISHED

    SELECT *
    FROM DerivativeTrades NATURAL JOIN ProductTrades NATURAL JOIN Products
    WHERE LastUserID = ?
    ORDER BY DateOfTrade DESC;

•	/api/reports?filter=<filter object>

  no report table

•	/api/rules?filter=<filter object>

  no rules table



POST

•	/api/check_trade

  haven't got database support for this yet

•	/api/trades

  INSERT INTO DerivativeTrades(DateOfTrade, AssetType, BuyingParty, SellingParty, NotionalAmount, Quantity, NotionalCurrency, MaturityDate, UnderlyingPrice, UnderlyingCurrency, StrikePrice, LastUserID, DateLastModified)
  VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'));

  this assumes that the tradeID is autogenerated, and so a value can't be supplied
  depends on how schema is defined
  DateLastModified could be generated client side, or by python, or by database

  if id generated by python then

  INSERT INTO DerivativeTrades
  VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'));


  INSERT INTO ProductTrades
  VALUES(?, ?);

  parameter order is ProductID, TradeID

  INSERT INTO EventLog
  VALUES(?, 'Added', datetime('now'), ?);

  parameter order is EventID, UserAction, DateOfEvent, EmployeeID


•	/api/rules

  no rules table

•	/api/companies

  INSERT INTO Companies
  VALUES(?, ?, ?);

  parameter order is CompanyCode, CompanyName, DateEnteredInSystem

•	/api/products

  INSERT INTO Products
  VALUES(?, ?)

  parameter order is CompanyCode, ProductName

  INSERT INTO ProductValuations
  VALUES(?, ?, ?);

  parameter order is DateOfValuation, ProductID, ProductPrice

  INSERT INTO ProductSellers
  VALUES(?, ?, ?);

  parameter order is ProductID, CompanyCode


PATCH

are these replacing every field? might be faster if it only updates the changed fields?

•	/api/trades/<tradeID>

  UPDATE DerivativeTrades
  SET DateOfTrade = ?, AssetType = ?, BuyingParty = ?, SellingParty = ?, NotionalValue = ?, NotionalCurrency = ?, Quantity = ?, MaturityDate = ?, UnderlyingValue = ?, UnderlyingCurrency = ?, StrikePrice = ?, LastUserID = ?
  WHERE TradeID = ?;

•	/api/rules/<ruleID>

  no rule table

•	/api/companies/<companyID>

  UPDATE Companies
  SET CompanyName = ?, DateEnteredInSystem = ?, CompanyCode = ?
  WHERE CompanyCode = ?;

•	/api/products/<productID>

  UPDATE ProductValuations
  SET DateOfValuation = ?, ProductPrice = ?
  WHERE ProductID = ?;

  UPDATE Products
  SET ProductName = ?, DateEnteredInSystem = ?
  WHERE ProductID = ?;


DELETE

•	/api/trades?id =<tradeID>

  DELETE FROM DerivativeTrades
  WHERE TradeID = ?;

•	/api/rules?id=<ruleID>
  no rule table

•	/api/companies?id=<companyID>
  DELETE FROM Companies
  WHERE CompanyCode = ?;

•	/api/products?id=<productID>

  DELETE FROM Products
  WHERE ProductID = ?;
